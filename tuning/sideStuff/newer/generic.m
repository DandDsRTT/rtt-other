genericSolver[
  (*
  
  optimizeGeneratorsTuningMapTargetingListNumerical - both unique and non-unique - have the same params.
  these are the only two functions for main.
   
  t_,
  unchangedIntervals_, (* trait -1 *)
  targetedIntervalsA_, (* trait 0 *)
  optimizationPower_, (* trait 1 *)
  damageWeightingSlope_, (* trait 2 *)
  complexityNormPower_, (* trait 3 *)
  complexityNegateLogPrimeCoordination_, (* trait 4a *)
  complexityPrimePower_, (* trait 4b *)
  complexitySizeFactor_, (* trait 4c *)
  complexityMakeOdd_ (* trait 4d *)
  
  then optimizeGeneratorsTuningMapTargetingAllNumericalDualNormIsPowerNorm - unique and non-unique - also share params
  
      t,
    unchangedIntervals, (* trait -1 *)
    complexityNormPower, (* trait 3 *)
    complexityNegateLogPrimeCoordination, (* trait 4a *)
    complexityPrimePower, (* trait 4b *)
    complexitySizeFactor, (* trait 4c *)
    complexityMakeOdd (* trait 4d *)
    
    optimizeGeneratorsTuningMapTargetingAllNumericalDualNormIsNotPowerNorm is special and we'll have to deal with it later

    so basically here we don't need traits 0,1,2 because we know {},âˆž,simplicity... but no harm in passing them in I guess
    but actually I think we want to break off later
    
    actually let's try working backwards
    lets do the unique version first
    
FINITE-TARGET-SET

INFINITE-TARGET-SET
    
    
*)



]
